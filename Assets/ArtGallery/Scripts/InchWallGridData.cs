using UnityEngine;

/// <summary>
/// Stores parametric data for grid points generated by InchWallBuilder.
/// Instead of storing every position, we keep grid dimensions and wall size
/// and compute positions on demand. (0,0) is top-left cell center.
/// </summary>
public class InchWallGridData : MonoBehaviour
{
    [SerializeField] private int cellsX;
    [SerializeField] private int cellsY;

    // Wall size in local-space Unity units (meters)
    [SerializeField] private float widthUnits;
    [SerializeField] private float heightUnits;

    // Local-space Z offset of the grid plane in front of the wall
    [SerializeField] private float zOffset;

    // If true, x = 0 is visually at the left when looking at the wall front
    [SerializeField] private bool flipX = true;

    // Simple occupancy + usage tracking for the center cell (optional smart detection)
    [SerializeField] private bool centerOccupied = false;
    [SerializeField] private ArtworkFrame centerArtworkFrame;

    // Artwork usage data at the center: how many 1x1 inch "pixels" (grid cells) it spans
    [SerializeField] private Vector2 centerSizeInches;
    [SerializeField] private int centerCellsX;
    [SerializeField] private int centerCellsY;
    [SerializeField] private int centerTotalCells;

    public int CellsX => cellsX;
    public int CellsY => cellsY;

    /// <summary>
    /// The ArtworkFrame currently registered as occupying the center region (may be part of a pair).
    /// </summary>
    public ArtworkFrame GetCenterArtworkFrame()
    {
        // Auto-clear if destroyed
        if (centerOccupied && centerArtworkFrame == null)
        {
            centerOccupied = false;
        }
        return centerArtworkFrame;
    }

    /// <summary>
    /// True if the logical center cell currently has an artwork registered.
    /// </summary>
    public bool IsCenterOccupied()
    {
        // If the stored frame was destroyed, clear the flag lazily.
        if (centerOccupied && centerArtworkFrame == null)
        {
            centerOccupied = false;
            centerSizeInches = Vector2.zero;
            centerCellsX = centerCellsY = centerTotalCells = 0;
        }
        return centerOccupied;
    }

    /// <summary>
    /// Registers an artwork frame as occupying the center cell and stores how many
    /// 1x1 inch grid cells ("pixels") it covers based on its size in inches.
    /// Call this after successful placement.
    /// </summary>
    public void MarkCenterOccupied(ArtworkFrame frame, Vector2 sizeInches)
    {
        centerArtworkFrame = frame;
        centerOccupied = frame != null;
        centerSizeInches = frame != null ? sizeInches : Vector2.zero;

        if (frame != null)
        {
            // Each grid cell is 1x1 inch, so cells ~= inches. Round to nearest whole cell.
            centerCellsX = Mathf.Max(1, Mathf.RoundToInt(sizeInches.x));
            centerCellsY = Mathf.Max(1, Mathf.RoundToInt(sizeInches.y));
            centerTotalCells = centerCellsX * centerCellsY;
        }
        else
        {
            centerCellsX = centerCellsY = centerTotalCells = 0;
        }
    }

    /// <summary>
    /// Returns the artwork size in inches that is currently occupying the center cell (if any).
    /// </summary>
    public Vector2 GetCenterSizeInches() => centerSizeInches;

    /// <summary>
    /// Returns how many 1x1 inch grid cells ("pixels") the center artwork spans horizontally and vertically.
    /// </summary>
    public void GetCenterCellUsage(out int cellsXUsed, out int cellsYUsed, out int totalCells)
    {
        cellsXUsed = centerCellsX;
        cellsYUsed = centerCellsY;
        totalCells = centerTotalCells;
    }

    /// <summary>
    /// Configure the parametric grid.
    /// cellsX/cellsY: number of cells horizontally/vertically.
    /// widthUnits/heightUnits: total size of the grid in local-space.
    /// zOffset: local-space z where the grid plane lies.
    /// </summary>
    public void Configure(int cellsX, int cellsY, float widthUnits, float heightUnits, float zOffset, bool flipX = true)
    {
        this.cellsX = Mathf.Max(1, cellsX);
        this.cellsY = Mathf.Max(1, cellsY);
        this.widthUnits = Mathf.Max(0.0001f, widthUnits);
        this.heightUnits = Mathf.Max(0.0001f, heightUnits);
        this.zOffset = zOffset;
        this.flipX = flipX;
    }

    /// <summary>
    /// Returns the local-space position of the cell center at (x, y), where (0,0) is top-left.
    /// Computed analytically to avoid storing a large array of positions.
    /// </summary>
    public Vector3 GetLocalPosition(int x, int y)
    {
        if (cellsX <= 0 || cellsY <= 0)
            return Vector3.zero;

        x = Mathf.Clamp(x, 0, cellsX - 1);
        y = Mathf.Clamp(y, 0, cellsY - 1);

        float stepX = widthUnits / cellsX;
        float stepY = heightUnits / cellsY;
        float halfWidth = widthUnits * 0.5f;
        float halfHeight = heightUnits * 0.5f;

        // y = 0 is top row
        float py = halfHeight - y * stepY - stepY * 0.5f;

        float px;
        if (flipX)
        {
            // x = 0 is left when looking at the wall front
            px = halfWidth - x * stepX - stepX * 0.5f;
        }
        else
        {
            // x = 0 is right when looking at the wall front
            px = -halfWidth + x * stepX + stepX * 0.5f;
        }

        return new Vector3(px, py, zOffset);
    }

    /// <summary>
    /// Returns the world-space position of the cell center at (x, y), where (0,0) is top-left.
    /// </summary>
    public Vector3 GetWorldPosition(int x, int y)
    {
        return transform.TransformPoint(GetLocalPosition(x, y));
    }

    /// <summary>
    /// Returns the local-space position of the TOP-LEFT corner of the grid cell at (x, y),
    /// where (0,0) is the top-left cell of the wall.
    /// </summary>
    public Vector3 GetLocalPixelTopLeft(int x, int y)
    {
        if (cellsX <= 0 || cellsY <= 0)
            return Vector3.zero;

        x = Mathf.Clamp(x, 0, cellsX - 1);
        y = Mathf.Clamp(y, 0, cellsY - 1);

        float stepX = widthUnits / cellsX;
        float stepY = heightUnits / cellsY;
        float halfWidth = widthUnits * 0.5f;
        float halfHeight = heightUnits * 0.5f;

        // Top-left of cell (x,y):
        // Horizontal: for x=0, at right wall edge (+halfWidth); moving left as x increases.
        // Vertical:   for y=0, at top edge (+halfHeight); moving down as y increases.
        float px = halfWidth - x * stepX;
        float py = halfHeight - y * stepY;

        return new Vector3(px, py, zOffset);
    }

    /// <summary>
    /// Returns the world-space position of the TOP-LEFT corner of the grid cell at (x, y).
    /// </summary>
    public Vector3 GetWorldPixelTopLeft(int x, int y)
    {
        return transform.TransformPoint(GetLocalPixelTopLeft(x, y));
    }
}
